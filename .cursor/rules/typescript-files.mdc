---
globs: *.ts,*.tsx
---

# TypeScript Files (.ts, .tsx) Rules

## Language Version & Features
- Target **TypeScript 5.0+** (or latest stable release)
- Target **ESNext** for maximum modern JavaScript features
- Use modern TypeScript features where appropriate:
  - Type inference for reduced verbosity
  - Union and intersection types
  - Discriminated unions for type-safe state management
  - Template literal types
  - `satisfies` operator for type narrowing
  - `const` assertions for literal types

## Code Style
- Use **2 spaces** for indentation
- Always run formatter before commit
- Naming conventions:
  - **Interfaces/Types**: PascalCase
  - **Functions/Variables**: camelCase
  - **Constants**: UPPER_SNAKE_CASE
  - **Files**: kebab-case.ts
- Prefer `const` over `let`, avoid `var`
- Use arrow functions for callbacks and short functions

## Module Organization
- Use ESNext modules (`import`/`export`)
- Group imports logically:
  1. External dependencies
  2. Internal modules
  3. Types
  4. Constants
- Prefer named exports over default exports
- Keep files focused and single-purpose

## Type Safety
- Avoid `any` type; use `unknown` when type is truly unknown
- Define explicit return types for public functions
- Use strict TypeScript settings (`strict: true`)
- Leverage type inference where it improves readability
- Create dedicated `.types.ts` files for shared types

## Error Handling
- Always handle errors explicitly
- Use custom error classes for domain-specific errors
- Provide meaningful error messages
- Log errors with context using structured logging
- Avoid throwing errors in normal control flow

## Logging
- Use **structured logging** consistently (tslog)
- Always include relevant context (IDs, parameters)
- Apply proper levels: debug, info, warn, error, fatal
- Never log sensitive data (tokens, passwords)

## Async/Await
- Always use `async`/`await` over raw Promises
- Handle promise rejections explicitly
- Use `Promise.all()` for parallel operations
- Add timeouts for external API calls
- Use `AbortController` for cancellable operations

## Best Practices
- Keep functions small and focused
- Use pure functions where possible
- Avoid global state
- Document complex logic with comments
- Write self-documenting code with clear naming
- Use functional programming patterns where appropriate
- Prefer composition over inheritance

## Environment Variables
- Validate environment variables at startup
- Use dedicated `.env.ts` files for configuration
- Never commit `.env` files to version control
- Provide `.env.example` with all required variables

## External Resources
- Encapsulate API calls in service modules
- Use retry logic for transient failures
- Implement proper timeouts
- Handle rate limiting gracefully
- Log all external API calls with context
